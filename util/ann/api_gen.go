package ann

import G "gorgonia.org/gorgonia"

// Code generated by genapi, which is a API generation tool for Gorgonia. DO NOT EDIT.

// BroadcastAdd performs a add. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastAdd(a, b *G.Node, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Add(a, b)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Add(a2, b2)
}

// BroadcastSub performs a sub. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastSub(a, b *G.Node, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Sub(a, b)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Sub(a2, b2)
}

// BroadcastHadamardProd performs a hadamardprod. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastHadamardProd(a, b *G.Node, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.HadamardProd(a, b)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.HadamardProd(a2, b2)
}

// BroadcastHadamardDiv performs a hadamarddiv. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastHadamardDiv(a, b *G.Node, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.HadamardDiv(a, b)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.HadamardDiv(a2, b2)
}

// BroadcastPow performs a pow. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastPow(a, b *G.Node, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Pow(a, b)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Pow(a2, b2)
}

// BroadcastLt performs a lt. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastLt(a, b *G.Node, retSame bool, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Lt(a, b, retSame)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Lt(a2, b2, retSame)
}

// BroadcastGt performs a gt. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastGt(a, b *G.Node, retSame bool, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Gt(a, b, retSame)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Gt(a2, b2, retSame)
}

// BroadcastLte performs a lte. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastLte(a, b *G.Node, retSame bool, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Lte(a, b, retSame)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Lte(a2, b2, retSame)
}

// BroadcastGte performs a gte. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastGte(a, b *G.Node, retSame bool, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Gte(a, b, retSame)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Gte(a2, b2, retSame)
}

// BroadcastEq performs a eq. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastEq(a, b *G.Node, retSame bool, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Eq(a, b, retSame)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Eq(a2, b2, retSame)
}

// BroadcastNe performs a ne. The operation is precomposed with a broadcast such that the shapes matches before operations commence.
func BroadcastNe(a, b *G.Node, retSame bool, leftPattern, rightPattern []byte) (*G.Node, error) {
	if a.Shape().Eq(b.Shape()) {
		return G.Ne(a, b, retSame)
	}
	a2, b2, err := G.Broadcast(a, b, G.NewBroadcastPattern(leftPattern, rightPattern))
	if err != nil {
		return nil, err
	}
	return G.Ne(a2, b2, retSame)
}
